/* instruction: byte pattern

   the declarations are attempting to match as closely as possible Intel's documentation.
   you will notice that some later additions to the instruction set start to depend on
   specific occurrences of prefixes. Older CPUs didn't really care all that much (this
   is probably why a lot of older DOS software fails on newer hardware). Various conditions
   are specified here, to help match opcodes to processors and decoding quirks. You
   are allowed to include other files as well, to help keep common declarations in one
   file.


   0xAA        direct byte value to match against

   REX.W       x64: promote word width to 64-bit
   
   /digit      mod/reg/rm byte, r/m is used for register or mem and reg field chooses the opcode

   /r          mod/reg/rm byte, r and r/m specify a register and register or memory reference

   cb/cw/cd/cp/co/ct  code offset as 1/2/4/6/8/10-byte value following the opcode, usually signed

   ib/iw/id/io immediate operand following the opcode, signed or unsigned

   +rb/+rw/+rd/+ro  register code, 0-7, added to the hexadecimal byte

   +i          register code, 0-7, added to the hexadecimal byte, referring to the FPU register st(i)

   rel8        relative address from -128 to 127, from the end of the instruction

   rel16/rel32/rel64  relative address in the same code segment, signed value, that is 16/32/64 bits wide, from end of instruction

   ptr16:16/ptr16:32/ptr16:64  far pointer, memory address

   r8          byte-wide general register (AL,CL,DL,BL,AH,CH,DH,BH etc)

   r16         word-wide general register

   r32         dword-wide general register

   r64         qword-wide general register (RAX, etc.)

   imm8        signed byte value, sign-extended if needed

   imm16       signed 16-bit value

   imm32       and so on

   imm64       and so on

   r/m8        byte side register or memory reference

   r/m16, r/m32, r/m64  and so on

   m           a word-size memory reference (16/32/64)

   m8          byte size memory reference

   m16/m32/m64/m128  and so on

   m16:16/m16:32/m16:64  memory operand pointing at far pointer

   m16&16/m16&32/m32&32/etc..  memory reference with pairs of values, each size given directly

   moffs8/moffs16/moffs32/...  memory address, relative to the segment

   sreg        segment register

   m32fp/m64fp/m80fp  memory reference to floating point value

   m16int/m32int/m64int  memory reference to integer, this form used for FPU instructions

   st          first FPU register st(0)
   st(i)       FPU register i

   mm          MMX register, 64 bits wide (0...7)

   mm/m32      low 32 bits of MMX, or 32-bit memory addr

   mm/m64      MMX register or 64-bit memory addr

   xmm         XMM register, 128 bits wide (0...7), REX extendable to 8...15

   xmm/m32     low 32 bits of XXM register? or 32-bit memory addr

   xmm/m64     low 64 bits of XXM register? or 64-bit memory addr
 
   xmm/m128    XMM register or memory addr

   <xmm0>      implied reference to XMM register X (here: register 0)

   

   Instructions by default are assumed to be encodeable in any mode.
   Whether the instruction is added to the table depends on the conditions
   described in the definition. If no conditions are added, the condition
   is "true".

   a condition starts with "if" such as:

   FOO: 0xAC /r if cpu >= 386
   
   combined conditions can be written using standard expression format:

   BAR: 0xAA /r if x64 && mod != 3 && cpu >= 386
   ASS: 0xC0 /r if (!x64 && mod == 2) || (x64 && mod == 1 && cpu == 286)

   Condition variables:

   x64                If 64-bit long mode is active
   a32                If 386 32-bit addressing prefix active (0x67 prefix in 16/64-bit, or 32-bit mode without prefix)
   d32                If 386 32-bit data prefix active (0x66 prefix in 16/64-bit, or 32-bit mode without prefix)
   p66                If 32-bit data prefix 0x66 was encountered (regardless of current mode)
   p67                If 32-bit address prefix 0x67 was encountered (regardless of current mode)
   pF2                If 0xF2 (REPE) prefix occured
   pF3                If 0xF3 (REPNE) prefix occured
   mod                mod bits of modregrm
   reg                reg bits of modregrm. if REX occured, 4th bit is combined into this value
   rm                 rm bits of modregrm. If REX occured, 4th bit is combined into this value
   word               if word-size parameter, typically this is set by the opcode statement
   everything         this is set to "1" if compiling a general decompiler intended to decompile every possible non-overlapping instruction
   cpu                an integer value representing the x86 level, for differentiating between pre-pentium2 CPUs. anything later is "686"
                             86 = 8086          186 = 80186          286 = 80286
                            386 = 80386         486 = 80486          586 = pentium
                            686 = pentium pro
   pentium            if Pentium or higher, which one 1=Pentium, 2=Pentium II, 3=Pentium III, 4=Pentium 4. anything newer still has pentium=4
   cmov               always 1, except if the target CPU does not have it
   mmx                an integer value that is 0 for no MMX, or 1 if so (TODO: multiple levels of MMX?)
   sse                an integer value that is 0 for no SSE, 1=SSE, 2=SSE2, 3=SSE3, 4=SSE4
   sss3               If SSES3 present
   sse4               SSE4 level, 0=only SSE4, 1=SSE4.1, 2=SSE4.2, etc...
   avx                AVX extensions
   aes                AES extensions
   3dnow              3DNow! extensions
   popcnt             Enable POPCNT
   switch             0=leave instruction operands alone, 1=instruction arguments are swapped (only applicable to first two arguments)
   wordsize           16, 32, or 64, depending on prefixes and mode
   bytewordsize       8, 16, 32, or 64. kind of like: word ? wordsize : 8
   opcode0            first byte of the opcode, excluding prefixes
   opcode1            second byte of the opcode
   opcode2            and so on...
   opb0               least significant bit of opcode0 (opcode0 & 1)
   opb1               2nd least significant bit of opcode0 ((opcode0 >> 1) & 1)
   
   Byte matching, Masking extension:
      Some opcodes use the least significant bits for word/byte size specification, etc or for register selection.
      Allowing masking saves my wrists by simply stating that, when said bits are masked off, the opcode should match this value.

   0xAA&1             Match byte value 0xAA after stripping off the lsb
   0xAC&1             Match 0xAC after stripping off two lsb's

   

   Prefix strictness:

   Earlier x86 processors didn't mind so much the prefix order, while later ones are more stringent.
   If desired, the system can be compiled to enforce the stricter form (typically when decompiler is
   used to emulate a processor).

   In addition, prefixes can be enabled and disabled depending on the target processor. To allow this,
   prefixes themselves are declared using names known to the compiler.

   ^data32: 0x66 if cpu >= 386

   Prefix names:

   ^data32
   ^addr32
   ^repne
   ^lock
   ^repe
   ^es
   ^cs
   ^ds
   ^ss
   ^fs
   ^gs
   ^rex
   ^vex


   Instruction arguments:

   ADD reg, r/m: 0x00&1 /r

   following the name, arguments are declared using the condition variables described above.

   The instruction can change condition variables before argument are evaluated:

   ADD { word=opb0,switch=opb1 } r/m, reg: 0x00&3 /r

   This declares 0x00-0x03 as ADD /r with r/m, reg defining the memory or register reference,
   but that bit 0 chooses between word size or byte size, and bit 1 if set switches the first
   two to become ADD reg, r/m.

*/
